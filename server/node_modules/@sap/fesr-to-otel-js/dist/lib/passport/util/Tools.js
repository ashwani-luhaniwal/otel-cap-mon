"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tools = void 0;
const uuid_1 = require("uuid");
class Tools {
    static getBytesFromString(s) {
        const bytes = [];
        for (let i = 0; i < s.length; ++i) {
            bytes.push(s.charCodeAt(i));
        }
        return bytes;
    }
    static createHexString(arr) {
        let result = "";
        for (const item of arr) {
            let str = item.toString(16);
            str = Array(2 - str.length + 1).join("0") + str;
            result += str;
        }
        return result;
    }
    static transformNumToHexArray(num) {
        const numberAsString = `${num}`;
        const hexArray = [];
        for (let i = 0; i < numberAsString.length; ++i) {
            const hex = (numberAsString.charCodeAt(i)).toString(16);
            hexArray.push(hex);
        }
        return hexArray;
    }
    static transformNumToHexString(num) {
        return Number(num).toString(16);
    }
    static encodeCorrelators(connectionId, connectionCounter, prevComp) {
        const capacity = 16 + 4 + 32; // connectionId + connectionCounter + prevCompName
        const buffer = new ArrayBuffer(capacity);
        const dataView = new DataView(buffer);
        let offset = dataView.byteOffset;
        const conBytes = (0, uuid_1.parse)(this.validateUuid(connectionId));
        for (const item of conBytes) {
            dataView.setInt8(offset, item);
            offset++;
        }
        dataView.setInt32(offset, connectionCounter, false);
        offset += 4;
        const prevCompBytes = this.stringToBytes(prevComp);
        for (const item of prevCompBytes) {
            dataView.setInt8(offset, item);
            offset++;
        }
        return this.arrayBufferToBase64(new DataView(dataView.buffer.slice(0, offset)));
    }
    static decodeCorrelators(tracestate) {
        let offset = 0;
        const buffer = Buffer.from(tracestate, "base64");
        const connBuffer = new Uint8Array(16);
        connBuffer.set(buffer.subarray(offset, 16), offset);
        const connectionId = (0, uuid_1.stringify)(connBuffer);
        offset = 16;
        const counterBuffer = new Uint8Array(4);
        counterBuffer.set(buffer.subarray(offset, offset + 4));
        const connectionCounter = ((counterBuffer[counterBuffer.length - 1]) |
            (counterBuffer[counterBuffer.length - 2] << 8) |
            (counterBuffer[counterBuffer.length - 3] << 16) |
            (counterBuffer[counterBuffer.length - 4] << 24));
        offset += 4;
        const prevComp = buffer.subarray(offset).toString("utf8");
        return {
            connectionId: connectionId,
            connectionCounter: connectionCounter,
            prevCompName: prevComp
        };
    }
    /**
     * a couple of passport elements haven't the defined length
     * in that case we must fill the gap with spaces
     * */
    static addSpaces(element, num) {
        //currently doesn't work method "fill" for arrays in TypeScript
        //so we must implemented as loop
        //maybe we can use this in the future
        for (let i = 0; i < num; i++) {
            element.push("20");
        }
        return element;
    }
    static transformStringToHex(str) {
        const hexArray = [];
        for (let i = 0; i < str.length; ++i) {
            const hex = (`${(str.charCodeAt(i)).toString(16)}`).toUpperCase();
            hexArray.push(hex);
        }
        return hexArray;
    }
    static transformBytesToHexString(binary) {
        return parseInt(binary, 2).toString(16).toUpperCase();
    }
    static transformHexStringToBytes(binary) {
        const bytes = parseInt(binary, 16).toString(2).toUpperCase();
        const rest = bytes.length % 4;
        return Tools.stringRepeat('0', rest) + bytes;
    }
    static transformHexToString(strAsHex) {
        let result = "";
        for (let offset = 0; offset < strAsHex.length; offset = offset + 2) {
            result += String.fromCharCode(parseInt(strAsHex.substring(offset, offset + 2), 16));
        }
        return result;
    }
    static transformHexToNumber(strAsHex) {
        return parseInt(strAsHex, 16);
    }
    static hexStringToHexArray(str) {
        const hexArray = [];
        for (let offset = 0; offset < str.length; offset = offset + 2) {
            hexArray.push(str.substring(offset, offset + 2));
        }
        return hexArray;
    }
    /**
     * use time tokens and a couple of random number to create a 32 Bit uuid
     */
    static createGUID() {
        const timeInMilliseconds = new Date().getTime();
        let result = timeInMilliseconds.toString(16).toUpperCase();
        let gap = 16 * 2 - result.length;
        //fill the rest with random numbers
        while (gap !== 0) {
            const numAsHex = Math.floor(1E3 * Math.random()).toString(16).toUpperCase();
            if (numAsHex.length <= gap) {
                result += numAsHex;
                gap -= numAsHex.length;
            }
            else {
                const diff = numAsHex.length - gap;
                result += numAsHex.substring(0, numAsHex.length - diff);
                gap = 0;
            }
        }
        return result;
    }
    /**
     * repeat is currently not supported in my version
     * here we use the version of mozilla
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
     * */
    static stringRepeat(str, repeat) {
        if (repeat < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (repeat === Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        repeat = Math.floor(repeat);
        if (str.length === 0 || repeat === 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * repeat >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        const maxCount = str.length * repeat;
        repeat = Math.floor(Math.log(repeat) / Math.log(2));
        while (repeat) {
            str += str;
            repeat--;
        }
        str += str.substring(0, maxCount - str.length);
        return str;
    }
    /**
     * change number to hex, fill with specific count of 0 and change it to array
     * **/
    static changeNumToPassportValue(num, expectedByteLength) {
        let numAsHex = Tools.transformNumToHexString(num).toUpperCase();
        numAsHex = Tools.stringRepeat('0', expectedByteLength * 2 - numAsHex.length) + numAsHex;
        return Tools.hexStringToHexArray(numAsHex);
    }
    static stringToBytes(s) {
        const arr = [];
        const buffer = Buffer.from(s, 'utf8');
        for (const element of buffer) {
            arr.push(element);
        }
        return arr;
    }
    static arrayBufferToBase64(dataView) {
        const buffer = Buffer.from(dataView.buffer);
        return buffer.toString("base64");
    }
    static validateUuid(uuid) {
        const dash1 = uuid.indexOf("-", 0);
        const dash2 = uuid.indexOf("-", dash1 + 1);
        const dash3 = uuid.indexOf("-", dash2 + 1);
        const dash4 = uuid.indexOf("-", dash3 + 1);
        if (dash4 < 0) {
            let res = uuid;
            res = res.replace(/-/g, "").toLowerCase();
            res = res.slice(0, 8) + "-" + res.slice(8);
            res = res.slice(0, 13) + "-" + res.slice(13);
            res = res.slice(0, 18) + "-" + res.slice(18);
            res = res.slice(0, 23) + "-" + res.slice(23);
            return res;
        }
        return uuid.toLowerCase();
    }
}
exports.Tools = Tools;
