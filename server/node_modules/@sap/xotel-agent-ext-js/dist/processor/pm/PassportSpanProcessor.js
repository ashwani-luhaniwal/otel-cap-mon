"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PassportSpanProcessor = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const PassportReadableSpan_1 = require("../../model/pm/PassportReadableSpan");
const constants = __importStar(require("../../utils/Constants"));
const PassportWrapper_1 = require("../../model/PassportWrapper");
const core_1 = require("@opentelemetry/core");
const Utils_1 = require("../../utils/Utils");
const passport_1 = require("../../lib/passport");
const api = __importStar(require("@opentelemetry/api"));
const Constants_1 = require("../../utils/Constants");
const logger_1 = require("../../common/logger");
const SpanType_1 = require("../../common/SpanType");
const NotificationPoller_1 = require("../../connectivity/NotificationPoller");
const MessageCountersForConsistencyCheck_1 = require("../../config/MessageCountersForConsistencyCheck");
class PassportSpanProcessor {
    constructor(exporter) {
        this.activeSpans = new Map();
        this.endedSpans = new Map();
        this.shutdownOnce = new core_1.BindOnceFuture(this.doShutdown, this);
        this.spanExporter = exporter;
    }
    forceFlush() {
        return Promise.resolve();
    }
    onStart(span, parentContext) {
        if (span.name == constants.UseCase.MOCKRECEIVER || span.name == constants.UseCase.MOCKSPANRECEIVER) {
            return;
        }
        let tenantId = parentContext.getValue(api.createContextKey(constants.CALM_ATT_TENANT_ID));
        if (tenantId == null) {
            tenantId = parentContext.getValue(api.createContextKey(constants.CALM_ATT_TENANCY_TENANT_ID));
        }
        const serviceType = constants.CALM_SERVICE_TYPE;
        if (typeof tenantId !== "string" || !NotificationPoller_1.NotificationPoller.isDataCollectionTurnedOn(serviceType, tenantId, Constants_1.UseCase.RUM.valueOf())) {
            logger_1.logger.debug(`PassportSpanProcessor onStart: data collection is switched off for ${serviceType}-${tenantId}-${Constants_1.UseCase.RUM.valueOf()}, don't process span`);
            return;
        }
        logger_1.logger.debug(`PassportSpanProcessor onStart: data collection is switched ON for ${serviceType}-${tenantId}-${Constants_1.UseCase.RUM.valueOf()}, processing span...`);
        this.setAttributes(span, parentContext);
        if (span.name !== Constants_1.FESR_SPAN_NAME) {
            this.handleNonFesrSpan(span, parentContext);
        }
    }
    onEnd(span) {
        if (this.shutdownOnce.isCalled) {
            return;
        }
        if (span.name == constants.UseCase.MOCKRECEIVER || span.name == constants.UseCase.MOCKSPANRECEIVER) {
            return;
        }
        let tenantId = span.resource.attributes[constants.CALM_ATT_TENANT_ID];
        if (tenantId == null) {
            tenantId = span.resource.attributes[constants.CALM_ATT_TENANCY_TENANT_ID];
        }
        const serviceType = constants.CALM_SERVICE_TYPE;
        if (typeof tenantId !== "string" || !NotificationPoller_1.NotificationPoller.isDataCollectionTurnedOn(serviceType, tenantId, Constants_1.UseCase.RUM.valueOf())) {
            logger_1.logger.debug(`PassportSpanProcessor onEnd: data collection is switched off for ${serviceType}-${tenantId}-${Constants_1.UseCase.RUM.valueOf()}, don't process span`);
            return;
        }
        logger_1.logger.debug(`PassportSpanProcessor onEnd: data collection is switched ON for ${serviceType}-${tenantId}-${Constants_1.UseCase.RUM.valueOf()}, processing span...`);
        const kind = span.kind;
        if (span.name === Constants_1.FESR_SPAN_NAME) {
            this.handleFesrSpan(span);
        }
        let spanType = (0, Utils_1.getSpanType)(span);
        let passportHex = span.attributes[(0, Utils_1.getPassportAttributeKey)(span.instrumentationLibrary)];
        if (spanType == undefined || passportHex == undefined) {
            logger_1.logger.debug(`PassportSpanProcessor: Ignoring end of span ${span.name}, SAP-PASSPORT=${passportHex}`);
            return;
        }
        if (typeof passportHex != "string") {
            logger_1.logger.debug(`PassportSpanProcessor: Ignoring erroneous passport ${passportHex}`);
            return;
        }
        let casted = span;
        const passportSpan = new PassportReadableSpan_1.PassportReadableSpan(casted, this.getPassport(passportHex));
        this.handleActiveSpans(passportSpan, kind, spanType, span);
    }
    handleActiveSpans(passportSpan, kind, spanType, span) {
        if (this.wasLastActiveSpan(passportSpan)) {
            let exporting = this.endedSpans.get(passportSpan.transId);
            if (exporting != undefined) {
                this.endedSpans.delete(passportSpan.transId);
                (0, MessageCountersForConsistencyCheck_1.incrementProducedMessageCounter)(1, "PM");
                this.doExport(exporting);
            }
            else {
                logger_1.logger.debug(`PassportSpanProcessor: Ignoring orphaned ${kind} span: ${span.name}`);
            }
        }
        else {
            logger_1.logger.debug(`PassportSpanProcessor: Span ${passportSpan.name} was not last active`);
        }
    }
    shutdown() {
        return this.shutdownOnce.call();
    }
    doShutdown() {
        return this.spanExporter.shutdown();
    }
    handlePassport(span, parentContext) {
        let passportWrapper = parentContext.getValue(api.createContextKey(constants.PASSPORT_KEY));
        if (passportWrapper == undefined) {
            let spanContext = span.spanContext();
            let traceId = spanContext.traceId;
            let spanId = spanContext.spanId;
            passportWrapper = new PassportWrapper_1.PassportWrapper(constants.CALM_SERVICE_NAME, {
                spanId: spanId,
                traceId: traceId
            });
        }
        if (!(passportWrapper instanceof PassportWrapper_1.PassportWrapper)) {
            throw Error('passportWrapper is not an instance of type PassportWrapper');
        }
        let passport = passportWrapper.getWrapped();
        if (span.kind.valueOf() === api_1.SpanKind.PRODUCER || span.kind.valueOf() === api_1.SpanKind.CLIENT) {
            passport = passportWrapper.getNextOutboundPassport();
        }
        return passport;
    }
    wasLastActiveSpan(span) {
        let transId = span.transId;
        let activeSpans = this.activeSpans.get(transId);
        activeSpans = activeSpans === null || activeSpans === void 0 ? void 0 : activeSpans.filter(s => !s.ended);
        if (activeSpans != undefined) {
            this.activeSpans.set(transId, activeSpans);
            let endedSpans = this.endedSpans.get(transId);
            if (endedSpans == undefined) {
                endedSpans = [];
            }
            endedSpans.push(span);
            this.endedSpans.set(transId, endedSpans);
            if ((activeSpans === null || activeSpans === void 0 ? void 0 : activeSpans.length) == 0) {
                this.activeSpans.delete(transId);
                return true;
            }
        }
        return false;
    }
    getPassport(hex) {
        let epp = new passport_1.DsrPassport(); // new DsrPassport Object
        epp.parsePassport(hex);
        return epp;
    }
    doExport(spans) {
        spans.sort((s1, s2) => (0, core_1.hrTimeToNanoseconds)(s1.startTime) - (0, core_1.hrTimeToNanoseconds)(s2.startTime));
        // prevent downstream exporter calls from generating spans
        api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            this.spanExporter.export(spans, result => {
                var _a;
                if (result.code !== core_1.ExportResultCode.SUCCESS) {
                    (0, core_1.globalErrorHandler)((_a = result.error) !== null && _a !== void 0 ? _a : new Error(`PassportSpanProcessor failed to export. Status: ${result})`));
                }
            });
        });
    }
    handleFesrSpan(span) {
        var _a;
        let rootContextId = span.attributes[constants.ATT_ROOT_CTX_ID];
        let transactionId = span.attributes[constants.ATT_TRANS_ID];
        let passportAction = span.attributes[constants.ATT_PP_ACTION];
        const passportHex = span.attributes[constants.PASSPORT_KEY];
        if (typeof rootContextId != "string"
            || typeof transactionId != "string"
            || typeof passportAction != "string"
            || typeof passportHex != "string") {
            logger_1.logger.warn(`PassportSpanProcessor: Invalid passport attributes from FESR: ${rootContextId}, ${transactionId}, ${passportAction}, ${passportHex}`);
            return;
        }
        const passport = new passport_1.DsrPassport();
        passport.parsePassport(passportHex);
        let casted = span;
        // const spanData = new PassportReadableSpan(span as Span, passport)
        let transId = passport.getTransactionId();
        if (this.activeSpans.has(transId)) {
            (_a = this.activeSpans.get(transId)) === null || _a === void 0 ? void 0 : _a.push(casted);
        }
        else {
            this.activeSpans.set(transId, [casted]);
        }
    }
    handleNonFesrSpan(span, parentContext) {
        var _a;
        let passport;
        try {
            passport = this.handlePassport(span, parentContext);
        }
        catch (error) {
            console.debug("This should never happen though");
            return;
        }
        span.attributes[(0, Utils_1.getPassportAttributeKey)(span.instrumentationLibrary)] = passport.getPassportAsString();
        let transId = passport.getTransactionId();
        if (this.activeSpans.has(transId)) {
            (_a = this.activeSpans.get(transId)) === null || _a === void 0 ? void 0 : _a.push(span);
        }
        else {
            this.activeSpans.set(transId, [span]);
        }
    }
    setAttributes(span, context) {
        const origin = context.getValue(api.createContextKey(constants.ATT_SUBDOMAIN));
        if (typeof origin == "string") {
            span.resource.attributes[constants.ATT_SUBDOMAIN] = origin;
        }
        const userId = context.getValue(api.createContextKey(constants.ATT_USER_ID));
        if (typeof userId == "string") {
            span.setAttribute(constants.ATT_USER_ID, userId);
        }
        const tenantId = context.getValue(api.createContextKey(constants.CALM_ATT_TENANT_ID));
        if (typeof tenantId == "string") {
            span.resource.attributes[constants.CALM_ATT_TENANT_ID] = tenantId;
        }
        const subaccountId = context.getValue(api.createContextKey(constants.CALM_ATT_TENANCY_TENANT_ID));
        if (typeof subaccountId == "string") {
            span.resource.attributes[constants.CALM_ATT_TENANCY_TENANT_ID] = subaccountId;
        }
        span.resource.attributes[constants.CALM_ATT_USE_CASE] = constants.UseCase.RUM.valueOf();
        span.resource.attributes[constants.CALM_ATT_ACTION] = "";
        span.resource.attributes[constants.CALM_ATT_ACTION_VERSION] = "";
        span.resource.attributes[constants.CALM_ATT_ACTION_CONTENT] = "";
        span.resource.attributes[constants.CALM_ATT_SERVICE_TYPE] = constants.CALM_SERVICE_TYPE;
        const type = (0, Utils_1.getSpanType)(span);
        if (SpanType_1.SpanType.HTTPS === type) {
            this.normalizeUrl(span);
        }
    }
    normalizeUrl(span) {
        const target = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_TARGET];
        if (target != null) {
            span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_TARGET] = (0, Utils_1.normalizeUrl)(target.toString());
        }
        const url = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
        if (url != null) {
            span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL] = (0, Utils_1.normalizeUrl)(url.toString());
        }
    }
}
exports.PassportSpanProcessor = PassportSpanProcessor;
