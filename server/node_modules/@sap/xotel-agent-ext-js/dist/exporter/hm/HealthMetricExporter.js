"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthMetricExporter = void 0;
const core_1 = require("@opentelemetry/core");
const NoopMetricExporter_1 = require("../NoopMetricExporter");
const NotificationPoller_1 = require("../../connectivity/NotificationPoller");
const Utils_1 = require("../../utils/Utils");
const Constants_1 = require("../../utils/Constants");
const logger_1 = require("../../common/logger");
class HealthMetricExporter {
    constructor() {
        this._exporter = new NoopMetricExporter_1.NoopMetricExporter();
    }
    set exporter(ex) {
        this._exporter = ex;
    }
    export(metrics, resultCallback) {
        const providerSubaccount = (0, Utils_1.getProviderSubaccount)();
        const serviceType = Constants_1.CALM_SERVICE_TYPE;
        if (typeof providerSubaccount !== "string" || !NotificationPoller_1.NotificationPoller.isDataCollectionTurnedOn(serviceType, providerSubaccount, Constants_1.UseCase.HEALTHMON.valueOf())) {
            logger_1.logger.debug(`HealthMetricExporter export: data collection is switched off for ${serviceType}-${providerSubaccount}-${Constants_1.UseCase.HEALTHMON.valueOf()}, don't export metrics`);
            resultCallback({
                code: core_1.ExportResultCode.SUCCESS
            });
            return;
        }
        this._exporter.export(metrics, resultCallback);
    }
    forceFlush() {
        return this._exporter.forceFlush();
    }
    selectAggregationTemporality(instrumentType) {
        return this._exporter.selectAggregationTemporality(instrumentType);
    }
    shutdown() {
        return this._exporter.shutdown();
    }
}
exports.HealthMetricExporter = HealthMetricExporter;
