"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HdbInstrumentation = void 0;
const pjson = require('../../../../package.json');
const logger_1 = require("../../../common/logger");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
class HdbInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = { enabled: true }) {
        super('opentelemetry-instrumentation-hdb', pjson.version, config);
    }
    init() {
        const { clientPatch, clientUnPatch } = this._getClientPatches();
        const { statementPatch, statementUnPatch } = this._getStatementPatches();
        return new instrumentation_1.InstrumentationNodeModuleDefinition('hdb', ['>=0.19.5'], undefined, undefined, [
            new instrumentation_1.InstrumentationNodeModuleFile('hdb/lib/Client.js', ['>=0.19.5'], clientPatch, clientUnPatch),
            new instrumentation_1.InstrumentationNodeModuleFile('hdb/lib/protocol/Statement.js', ['>=0.19.5'], statementPatch, statementUnPatch),
        ]);
    }
    _getClientPatches() {
        return {
            clientPatch: (moduleExports, moduleVersion) => {
                logger_1.logger.debug(`Patching hdb client version ${moduleVersion}`);
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.commit)) {
                    this._unwrap(moduleExports.prototype, 'commit');
                }
                this._wrap(moduleExports.prototype, 'commit', this._patchClientCommit());
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.rollback)) {
                    this._unwrap(moduleExports.prototype, 'rollback');
                }
                this._wrap(moduleExports.prototype, 'rollback', this._patchClientRollback());
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.prepare)) {
                    this._unwrap(moduleExports.prototype, 'prepare');
                }
                this._wrap(moduleExports.prototype, 'prepare', this._patchClientStatement('prepare'));
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.exec)) {
                    this._unwrap(moduleExports.prototype, 'exec');
                }
                this._wrap(moduleExports.prototype, 'exec', this._patchClientStatement('exec'));
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.execute)) {
                    this._unwrap(moduleExports.prototype, 'execute');
                }
                this._wrap(moduleExports.prototype, 'execute', this._patchClientStatement('execute'));
                return moduleExports;
            },
            clientUnPatch: (moduleExports, moduleVersion) => {
                if (moduleExports === undefined) {
                    return;
                }
                logger_1.logger.debug(`Removing patches from hdb client version ${moduleVersion}`);
                const prototype = Object.getPrototypeOf(moduleExports);
                this._unwrap(prototype, 'commit');
                this._unwrap(prototype, 'rollback');
                this._unwrap(prototype, 'prepare');
                this._unwrap(prototype, 'exec');
                this._unwrap(prototype, 'execute');
            },
        };
    }
    _getStatementPatches() {
        return {
            statementPatch: (moduleExports, moduleVersion) => {
                logger_1.logger.debug(`Patching hdb statement version ${moduleVersion}`);
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.exec)) {
                    this._unwrap(moduleExports.prototype, 'exec');
                }
                this._wrap(moduleExports.prototype, 'exec', this._patchStatementExec('exec'));
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.execute)) {
                    this._unwrap(moduleExports.prototype, 'execute');
                }
                this._wrap(moduleExports.prototype, 'execute', this._patchStatementExec('execute'));
                if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.drop)) {
                    this._unwrap(moduleExports.prototype, 'drop');
                }
                this._wrap(moduleExports.prototype, 'drop', this._patchStatementDrop());
                return moduleExports;
            },
            statementUnPatch: (moduleExports, moduleVersion) => {
                if (moduleExports === undefined) {
                    return;
                }
                logger_1.logger.debug(`Removing patches from hdb statement version ${moduleVersion}`);
                const prototype = Object.getPrototypeOf(moduleExports);
                this._unwrap(prototype, 'exec');
                this._unwrap(prototype, 'execute');
                this._unwrap(prototype, 'drop');
            },
        };
    }
    _patchClientCommit() {
        const me = this;
        return (original) => {
            return function patchClientCommit(callback) {
                const span = me.tracer.startSpan('hdb.client.commit', {
                    kind: api_1.SpanKind.CLIENT,
                });
                span.setAttributes({
                    [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: 'commit',
                });
                if (callback === undefined) {
                    const spanContext = api_1.trace.setSpan(api_1.context.active(), span);
                    const result = api_1.context.with(spanContext, original, this, ...arguments);
                    span.end();
                    return result;
                }
                const patchedCallback = me._patchCallback(span, callback);
                return original.call(this, patchedCallback);
            };
        };
    }
    _patchClientRollback() {
        const me = this;
        return (original) => {
            return function patchClientRollback(callback) {
                const span = me.tracer.startSpan('hdb.client.rollback', {
                    kind: api_1.SpanKind.CLIENT,
                });
                span.setAttributes({
                    [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: 'rollback',
                });
                if (callback === undefined) {
                    const spanContext = api_1.trace.setSpan(api_1.context.active(), span);
                    const result = api_1.context.with(spanContext, original, this, ...arguments);
                    span.end();
                    return result;
                }
                const patchedCallback = me._patchCallback(span, callback);
                return original.call(this, patchedCallback);
            };
        };
    }
    _patchClientStatement(prop) {
        const me = this;
        return (original) => {
            return function patchClientStatement(command, options, callback) {
                const span = me.tracer.startSpan(`hdb.client.${prop}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                span.setAttributes({
                    [semantic_conventions_1.SemanticAttributes.DB_STATEMENT]: command,
                });
                if (callback === undefined) {
                    const spanContext = api_1.trace.setSpan(api_1.context.active(), span);
                    const result = api_1.context.with(spanContext, original, this, ...arguments);
                    span.end();
                    return result;
                }
                const patchedCallback = me._patchCallback(span, callback);
                return original.call(this, command, options, patchedCallback);
            };
        };
    }
    _patchStatementExec(prop) {
        const me = this;
        return (original) => {
            return function patchStatementExec(values, options, callback) {
                const span = me.tracer.startSpan(`hdb.statement.${prop}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                span.setAttributes({
                    [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: `statement ${prop}`,
                });
                if (callback === undefined) {
                    const spanContext = api_1.trace.setSpan(api_1.context.active(), span);
                    const result = api_1.context.with(spanContext, original, this, ...arguments);
                    span.end();
                    return result;
                }
                const patchedCallback = me._patchCallback(span, callback);
                return original.call(this, values, options, patchedCallback);
            };
        };
    }
    _patchStatementDrop() {
        const me = this;
        return (original) => {
            return function patchClientCommit(callback) {
                const span = me.tracer.startSpan('hdb.statement.drop', {
                    kind: api_1.SpanKind.CLIENT,
                });
                span.setAttributes({
                    [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: 'drop',
                });
                if (callback === undefined) {
                    const spanContext = api_1.trace.setSpan(api_1.context.active(), span);
                    const result = api_1.context.with(spanContext, original, this, ...arguments);
                    span.end();
                    return result;
                }
                const patchedCallback = me._patchCallback(span, callback);
                return original.call(this, patchedCallback);
            };
        };
    }
    _patchCallback(span, callback) {
        const activeContext = api_1.context.active();
        return function patchedCallBack(...args) {
            const error = args[0];
            if (error instanceof Error) {
                span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message,
                });
            }
            span.end();
            return api_1.context.with(activeContext, () => {
                return callback.apply(this, args);
            });
        };
    }
}
exports.HdbInstrumentation = HdbInstrumentation;
