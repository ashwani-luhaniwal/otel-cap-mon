"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Init = exports.enableCertificateAuthentication = exports.certificateRuntimeFlow = exports.deleteCertificate = exports.createCertificate = exports.getDestination = exports.getCertificateAndValidate = exports.isValidCertficateChain = exports.splitCertificateChain = exports.getOAuthToken = exports.generateOAuthToken = exports.getMetricCollectorOptions = exports.getTraceCollectorOptions = exports.getClientKeyAndCertificate = exports.isDestinationServiceEnabled = exports.getVcapApplication = exports.getVcapDestination = void 0;
const xsenv = require("@sap/xsenv");
xsenv.loadEnv();
const oCfenv = require("cfenv");
const oAppEnv = oCfenv.getAppEnv();
const node_forge_1 = require("node-forge");
const logger_1 = require("../common/logger");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const CommonOtlpTraceExporter_1 = require("../exporter/CommonOtlpTraceExporter");
const OAuthService = __importStar(require("./OAuthService"));
const NotificationPoller_1 = require("./NotificationPoller");
const InitializeEndpoints = __importStar(require("./InitializeEndpoints"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const CommonOtlpMetricExporter_1 = require("../exporter/CommonOtlpMetricExporter");
const https_1 = __importDefault(require("https"));
let destination;
let vcapApplication;
let CLIENT_KEY;
let CLIENT_CERTIFICATE;
const SERVICE_TYPE = process.env.SAP_CALM_SERVICE_TYPE || "";
const DATACENTER = process.env.SAP_CALM_POLL_DC || "";
const POLL_INTERVAL = Number(process.env.OTEL_POLL_INTERVAL) || 300;
let hasDestination = false;
const envDetector_1 = require("../utils/envDetector");
const Constants_1 = require("../utils/Constants");
const { isPrerequisitesMatched, detectedInfrastructure } = envDetector_1.EnvDetector.validateInfrastructure();
if (detectedInfrastructure === Constants_1.Environment.CF && process.env.VCAP_SERVICES != undefined && isPrerequisitesMatched) {
    const VCAP_SERVICES = JSON.parse(process.env.VCAP_SERVICES);
    destination = VCAP_SERVICES.destination[0].credentials;
}
else {
    logger_1.logger.error(`DestinationService: VCAP_SERVICES config is not present`);
}
if (process.env.VCAP_APPLICATION !== undefined) {
    vcapApplication = JSON.parse(process.env.VCAP_APPLICATION);
}
else {
    logger_1.logger.error(`DestinationService: VCAP_APPLICATION config is not present`);
}
function getVcapDestination() {
    return destination;
}
exports.getVcapDestination = getVcapDestination;
function getVcapApplication() {
    return vcapApplication;
}
exports.getVcapApplication = getVcapApplication;
function isDestinationServiceEnabled() {
    return hasDestination;
}
exports.isDestinationServiceEnabled = isDestinationServiceEnabled;
function getClientKeyAndCertificate() {
    return {
        key: CLIENT_KEY,
        cert: CLIENT_CERTIFICATE
    };
}
exports.getClientKeyAndCertificate = getClientKeyAndCertificate;
const serviceType = process.env.SAP_CALM_SERVICE_TYPE;
const traceCollectorOptions = {
    timeoutMillis: 5000,
    concurrencyLimit: 10 // an optional limit on pending requests
};
const metricCollectorOptions = Object.assign(Object.assign({}, traceCollectorOptions), { temporalityPreference: sdk_metrics_1.AggregationTemporality.DELTA });
// OK HTTP Client is it cached and re-used like a pool ?
const getTraceCollectorOptions = () => {
    return traceCollectorOptions;
};
exports.getTraceCollectorOptions = getTraceCollectorOptions;
const getMetricCollectorOptions = () => {
    return metricCollectorOptions;
};
exports.getMetricCollectorOptions = getMetricCollectorOptions;
const parseBase64Certificate = (rawBase64) => {
    return node_forge_1.pki.certificateFromPem(rawBase64);
};
function getSpaceName() {
    return oAppEnv.app.space_name;
}
const generateOAuthToken = (tokenUrl, opts) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise(function (resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, node_fetch_1.default)(`${tokenUrl}/oauth/token`, opts)
                .then((resp) => __awaiter(this, void 0, void 0, function* () {
                if (!resp.ok) {
                    const res = yield resp.json();
                    logger_1.logger.error(`DestinationService: error occured in generating OAuth ${res.error} with ${resp.status} using credential based`);
                    reject(res);
                }
                else {
                    const res = yield resp.json();
                    resolve(res);
                }
            }))
                .catch(e => {
                logger_1.logger.error(`DestinationService: error occured in generating OAuth ${e.message}`);
                reject(e);
            });
        });
    });
});
exports.generateOAuthToken = generateOAuthToken;
function getOAuthToken(credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        let options;
        if (credentials.certificate && credentials.key && credentials.certurl && credentials.clientid) {
            logger_1.logger.debug(`DestinationService: enabling certificate based destination binding`);
            options = {
                method: "POST",
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    "Content-Security-Policy": "script-src 'self'"
                },
                body: `grant_type=client_credentials&client_id=${credentials.clientid}`,
                agent: new https_1.default.Agent({
                    cert: credentials.certificate,
                    key: credentials.key
                })
            };
            return yield (0, exports.generateOAuthToken)(credentials.certurl, options);
        }
        else if (credentials.clientid && credentials.clientsecret) {
            logger_1.logger.debug(`DestinationService: enabling client secret based destination binding`);
            options = {
                method: "POST",
                headers: {
                    'Authorization': 'Basic ' + Buffer.from(credentials.clientid + ':' + credentials.clientsecret).toString('base64'),
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `grant_type=client_credentials&client_id=${credentials.clientid}`,
            };
            return yield (0, exports.generateOAuthToken)(credentials.url, options);
        }
        else {
            throw new Error(`Couldn't fetch access token using given configs in VCAP_SERVICES`);
        }
    });
}
exports.getOAuthToken = getOAuthToken;
function splitCertificateChain(certificateChain) {
    const certificates = [];
    const arrayOfLines = certificateChain.split("\n");
    let currentCert = [];
    for (let i = 0; i < arrayOfLines.length; i++) {
        let line = arrayOfLines[i];
        if (!(line.length !== 0)) {
            continue;
        }
        currentCert.push(line);
        if (line.match(/-END CERTIFICATE-/)) {
            certificates.push(currentCert.join("\n"));
            currentCert = [];
        }
    }
    return certificates;
}
exports.splitCertificateChain = splitCertificateChain;
function isValidCertficateChain(certificateChain) {
    const certificates = splitCertificateChain(certificateChain);
    if (certificates.length > 0) {
        for (let certificate of certificates) {
            const parcedCrt = parseBase64Certificate(certificate);
            const t1 = parcedCrt.validity.notAfter.getTime();
            const t2 = Date.now();
            if ((t1 - t2) <= (60 * 60 * 1000)) { // Check if Validity is lesser than 1hr
                return false;
            }
        }
    }
    else {
        return false;
    }
    return true;
}
exports.isValidCertficateChain = isValidCertficateChain;
const getCertificateAndValidate = (certificateName, token) => __awaiter(void 0, void 0, void 0, function* () {
    const isValid = false;
    return new Promise(function (resolve, _reject) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                logger_1.logger.debug(`DestinationService: Getting certificate :  ${encodeURI(certificateName)}`);
                const options = {
                    headers: {
                        'Authorization': `Bearer ${token.access_token}`,
                        'Content-Type': 'application/json'
                    },
                    method: 'GET'
                };
                yield (0, node_fetch_1.default)(`${destination.uri}/destination-configuration/v1/instanceCertificates/${encodeURI(certificateName)}`, options)
                    .then((response) => __awaiter(this, void 0, void 0, function* () {
                    if (!response.ok) {
                        return resolve({
                            isValid: isValid,
                            isFound: false,
                            certKeyPair: undefined
                        });
                    }
                    else {
                        const content = (yield response.json()).Content;
                        const bufferObj = Buffer.from(content, "base64");
                        const rawCertKeyObj = bufferObj.toString("utf8");
                        const rawCertObj = rawCertKeyObj.replace(/-----BEGIN PRIVATE KEY[-=+\w\n\d\s/]*END PRIVATE KEY-----/g, '');
                        if (isValidCertficateChain(rawCertObj)) { // Check if Validity of certificate chain is greater than 1hr
                            return resolve({
                                isFound: true,
                                isValid: true,
                                certKeyPair: rawCertKeyObj
                            });
                        }
                        return resolve({
                            isFound: true,
                            isValid: false,
                            certKeyPair: rawCertKeyObj
                        });
                    }
                }));
            }
            catch (error) {
                logger_1.logger.error(`DestinationService: Error in getting certificate ${error}`);
                return resolve({
                    isFound: false,
                    isValid: false,
                    certKeyPair: undefined
                });
            }
        });
    });
});
exports.getCertificateAndValidate = getCertificateAndValidate;
const fetchDestination = (url, options) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        (0, node_fetch_1.default)(url, options)
            .then((response) => __awaiter(void 0, void 0, void 0, function* () { return resolve(response); }))
            .catch(error => {
            logger_1.logger.error(`DestinationService: error in fetching destination for ${getSpaceName()}, error is ${error}`);
            return reject(error);
        });
    }));
});
const getDestination = (token) => __awaiter(void 0, void 0, void 0, function* () {
    const destinationUri = `${destination.uri}/destination-configuration/v1/subaccountDestinations`;
    const options = {
        headers: {
            'Authorization': `Bearer ${token.access_token}`,
            'Content-Type': 'application/json'
        },
        method: 'GET'
    };
    const response = yield fetchDestination(`${destinationUri}/CALM_datacollector_${getSpaceName()}`, options);
    if (!response.ok) {
        logger_1.logger.info(`DestinationService: trying fallback destination`);
        const resp = yield fetchDestination(`${destinationUri}/CALM_datacollector`, options);
        if (!resp.ok) {
            logger_1.logger.error(`DestinationService: could not fetch destination using fallback as well`);
            return Promise.reject(resp.json());
        }
        else {
            return Promise.resolve(resp.json());
        }
    }
    else {
        return Promise.resolve(response.json());
    }
});
exports.getDestination = getDestination;
const createCertificate = (certificateName, token) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.logger.debug(`DestinationService: Creating certificate :  ${encodeURI(certificateName)}`);
    const jsonBody = {
        Name: certificateName,
        Attributes: {
            CN: `CALM_datacollector_${serviceType}_${getSpaceName()}`,
            Validity: {
                TimeUnit: "DAYS",
                Value: 1
            },
            AutomaticRenew: true
        }
    };
    const options = {
        method: "post",
        headers: {
            'Authorization': `Bearer ${token.access_token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(jsonBody),
    };
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        (0, node_fetch_1.default)(`${destination.uri}/destination-configuration/v1/instanceCertificates`, options)
            .then((response) => __awaiter(void 0, void 0, void 0, function* () {
            if (!response.ok) {
                reject(yield response.json());
            }
            else {
                logger_1.logger.debug(`DestinationService: certificate created ${response}`);
                resolve(response.status);
            }
        }))
            .catch((error) => {
            logger_1.logger.error(`DestinationService: Error Creating certificate : ${encodeURI(certificateName)} : ${error.message}`);
            reject(error);
        });
    }));
});
exports.createCertificate = createCertificate;
const deleteCertificate = (certificateName, token) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.logger.debug(`DestinationService: Deleting certificate : ${encodeURI(certificateName)}`);
    yield (0, node_fetch_1.default)(`${destination.uri}/destination-configuration/v1/instanceCertificates/${encodeURI(certificateName)}`, {
        method: "DELETE",
        headers: {
            'Authorization': `Bearer ${token.access_token}`,
        },
    }).catch(error => {
        logger_1.logger.error(`DestinationService: Error Deleting certificate : ${encodeURI(certificateName)} : ${error.message}`);
    });
});
exports.deleteCertificate = deleteCertificate;
const certificateRuntimeFlow = (certificateName, token) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.logger.debug(`DestinationService: Certificate runtime flow Starting for cert:${encodeURI(certificateName)}`);
    let result;
    result = yield (0, exports.getCertificateAndValidate)(certificateName, token);
    if (!result.isFound) {
        logger_1.logger.debug(`Creating certificate`);
        yield (0, exports.createCertificate)(certificateName, token);
        result = yield (0, exports.getCertificateAndValidate)(certificateName, token);
    }
    else if (!result.isValid) {
        logger_1.logger.debug(`Existing certificate expired, hence creating new one`);
        yield (0, exports.deleteCertificate)(certificateName, token);
        yield (0, exports.createCertificate)(certificateName, token);
        result = yield (0, exports.getCertificateAndValidate)(certificateName, token);
    }
    CLIENT_KEY = result.certKeyPair;
    CLIENT_CERTIFICATE = result.certKeyPair;
});
exports.certificateRuntimeFlow = certificateRuntimeFlow;
const enableCertificateAuthentication = (certificateName) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.logger.debug(`DestinationService: Certificate Authentication runtime flow Starting for cert:${encodeURI(certificateName)}`);
    const timeOut = 45 * 60 * 1000; // 45 Minutes Time Interval
    try {
        let token = yield getOAuthToken(destination);
        yield (0, exports.certificateRuntimeFlow)(certificateName, token);
        const httpOptions = {
            keepAlive: true,
            maxSockets: 10,
            maxFreeSockets: 3,
            timeout: 60000,
            cert: getClientKeyAndCertificate().cert,
            key: getClientKeyAndCertificate().key
        };
        traceCollectorOptions.httpAgentOptions = httpOptions;
        metricCollectorOptions.httpAgentOptions = httpOptions;
        CommonOtlpTraceExporter_1.CommonOtlpTraceExporter.init(traceCollectorOptions);
        CommonOtlpMetricExporter_1.CommonOtlpMetricExporter.init(metricCollectorOptions);
    }
    catch (error) {
        logger_1.logger.error(`DestinationService: Error in fetching token ${error.message}`);
    }
    setInterval(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
            let token = yield getOAuthToken(destination);
            yield (0, exports.certificateRuntimeFlow)(certificateName, token);
            const httpOptions = {
                keepAlive: true,
                maxSockets: 10,
                maxFreeSockets: 3,
                timeout: 60000,
                cert: getClientKeyAndCertificate().cert,
                key: getClientKeyAndCertificate().key
            };
            traceCollectorOptions.httpAgentOptions = httpOptions;
            metricCollectorOptions.httpAgentOptions = httpOptions;
            CommonOtlpTraceExporter_1.CommonOtlpTraceExporter.reInit(traceCollectorOptions);
            CommonOtlpMetricExporter_1.CommonOtlpMetricExporter.reInit(metricCollectorOptions);
        }
        catch (error) {
            logger_1.logger.error(`DestinationService: Error in fetching token ${error.message}`);
        }
    }), timeOut);
});
exports.enableCertificateAuthentication = enableCertificateAuthentication;
const Init = () => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield getOAuthToken(destination);
    yield (0, exports.getDestination)(token)
        .then((response) => __awaiter(void 0, void 0, void 0, function* () {
        if (!response.URL) {
            logger_1.logger.error(`DestinationService: destination could not be fetched with error ${response.ErrorMessage}`);
        }
        else {
            // Initializing dynamic URL for span export at DCR endpoint 
            const baseUrls = yield InitializeEndpoints.initialize(response); //response.URL
            traceCollectorOptions.url = baseUrls.endPointTraces;
            metricCollectorOptions.url = baseUrls.endPointMetrics;
            if (response.Authentication === 'NoAuthentication') {
                // Enabling Certificate based authentication - as per authentication type
                const certificateName = `CALM_datacollector_${serviceType}_${getSpaceName()}.pem`;
                yield (0, exports.enableCertificateAuthentication)(certificateName);
                yield NotificationPoller_1.NotificationPoller.init(baseUrls.pollingBaseURL, SERVICE_TYPE, DATACENTER, POLL_INTERVAL);
            }
            else if (response.Authentication === 'OAuth2ClientCredentials') {
                // Enabling OAuth Based authentication - as per authentication type
                const clientId = response.clientId;
                const clientSecret = response.clientSecret;
                const tokenUrl = response.tokenServiceURL;
                yield OAuthService.initCustomerOAuth(clientId, clientSecret, tokenUrl);
                yield NotificationPoller_1.NotificationPoller.init(baseUrls.pollingBaseURL, SERVICE_TYPE, DATACENTER, POLL_INTERVAL);
            }
            hasDestination = true;
        }
    }))
        .catch(e => {
        logger_1.logger.error(`DestinationService: could not fetch destination using oauth token, error ${JSON.stringify(e)}`);
    });
});
exports.Init = Init;
